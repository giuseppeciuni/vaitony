<script>
// Quick Note System Functions
function initQuickNoteSystem() {
    const quickNoteInput = document.getElementById('quick-note-input');
    const saveNoteBtn = document.getElementById('save-note-btn');
    const clearBtn = document.getElementById('clear-btn');
    const pasteBtn = document.getElementById('paste-btn');
    const charCount = document.getElementById('char-count');
    const toolbar = document.querySelector('.note-toolbar');
    const dropZone = document.getElementById('drop-zone');
    const includeInRag = document.getElementById('include-in-rag');

    // Mostra/nascondi toolbar
    quickNoteInput.addEventListener('focus', () => {
        toolbar.classList.remove('d-none');
        toolbar.classList.add('d-flex');
        // Auto-resize textarea
        quickNoteInput.style.height = 'auto';
        quickNoteInput.style.height = quickNoteInput.scrollHeight + 'px';
    });

    // Update char count e abilita/disabilita save button
    quickNoteInput.addEventListener('input', () => {
        const count = quickNoteInput.value.length;
        charCount.textContent = count;
        saveNoteBtn.disabled = count === 0;

        // Auto-resize
        quickNoteInput.style.height = 'auto';
        quickNoteInput.style.height = quickNoteInput.scrollHeight + 'px';
    });

    // Paste button
    pasteBtn.addEventListener('click', async () => {
        try {
            const text = await navigator.clipboard.readText();
            quickNoteInput.value += text;
            quickNoteInput.dispatchEvent(new Event('input'));
        } catch (err) {
            console.error('Failed to read clipboard:', err);
        }
    });

    // Clear button
    clearBtn.addEventListener('click', () => {
        quickNoteInput.value = '';
        quickNoteInput.dispatchEvent(new Event('input'));
        quickNoteInput.focus();
    });

    // Save note
    saveNoteBtn.addEventListener('click', () => {
        const content = quickNoteInput.value.trim();
        if (!content) return;

        // Disabilita i controlli durante il salvataggio
        saveNoteBtn.disabled = true;
        quickNoteInput.disabled = true;

        fetch('{% url "project" project.id %}', {
            method: 'POST',
            headers: {
                'X-Requested-With': 'XMLHttpRequest',
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
                'action': 'add_note',
                'project_id': '{{ project.id }}',
                'content': content,
                'csrfmiddlewaretoken': '{{ csrf_token }}'
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Pulisci il campo
                quickNoteInput.value = '';
                quickNoteInput.dispatchEvent(new Event('input'));

                // Mostra notifica di successo
                showToast('Nota salvata con successo!', 'success');

                // Aggiorna la lista delle note (per ora ricarica la pagina)
                location.reload(); // In produzione, aggiornare dinamicamente
            } else {
                showToast('Errore: ' + (data.error || 'Impossibile salvare la nota'), 'danger');
            }
        })
        .catch(error => {
            console.error('Errore:', error);
            showToast('Errore di rete', 'danger');
        })
        .finally(() => {
            // Riabilita i controlli
            saveNoteBtn.disabled = false;
            quickNoteInput.disabled = false;
            quickNoteInput.focus();
        });
    });

    // Keyboard shortcuts
    quickNoteInput.addEventListener('keydown', (e) => {
        // Ctrl/Cmd + Enter to save
        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
            e.preventDefault();
            if (!saveNoteBtn.disabled) {
                saveNoteBtn.click();
            }
        }
    });

    // Drag and drop support
    document.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.classList.remove('d-none');
        dropZone.classList.add('dragover');
    });

    document.addEventListener('dragleave', (e) => {
        if (!e.relatedTarget) {
            dropZone.classList.add('d-none');
            dropZone.classList.remove('dragover');
        }
    });

    document.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.add('d-none');
        dropZone.classList.remove('dragover');

        const text = e.dataTransfer.getData('text/plain');
        if (text) {
            quickNoteInput.value += text;
            quickNoteInput.dispatchEvent(new Event('input'));
            quickNoteInput.focus();
        }
    });
}

// Toast notification function
function showToast(message, type = 'info') {
    const toastContainer = document.querySelector('.toast-container') || createToastContainer();

    const toast = document.createElement('div');
    toast.className = `toast align-items-center text-white bg-${type} border-0`;
    toast.setAttribute('role', 'alert');
    toast.setAttribute('aria-live', 'assertive');
    toast.setAttribute('aria-atomic', 'true');

    toast.innerHTML = `
        <div class="d-flex">
            <div class="toast-body">
                ${message}
            </div>
            <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
    `;

    toastContainer.appendChild(toast);
    const bsToast = new bootstrap.Toast(toast);
    bsToast.show();

    toast.addEventListener('hidden.bs.toast', () => {
        toast.remove();
    });
}

function createToastContainer() {
    const container = document.createElement('div');
    container.className = 'toast-container position-fixed bottom-0 end-0 p-3';
    document.body.appendChild(container);
    return container;
}

// Sistema di crawling del sito web
function initWebsiteCrawler() {
    const crawlForm = document.getElementById('website-crawl-form');
    const startCrawlBtn = document.getElementById('start-crawl-btn');
    const cancelCrawlBtn = document.getElementById('cancel-crawl-btn');
    const crawlStatusArea = document.getElementById('crawl-status-area');
    const crawlStatusMessage = document.getElementById('crawl-status-message');
    const currentUrlDisplay = document.getElementById('current-url');
    const processedLinksContainer = document.getElementById('processed-links-list');
    const processedPagesCount = document.getElementById('processed-pages-count');
    const queuedPagesCount = document.getElementById('queued-pages-count');
    const failedPagesCount = document.getElementById('failed-pages-count');

    // Variabili di stato del crawling
    let crawlInProgress = false;
    let crawlJob = null;
    let processedPages = 0;
    let queuedPages = 0;
    let failedPages = 0;
    let crawledLinks = [];
    let monitorInterval = null;

    if (crawlForm) {
        crawlForm.addEventListener('submit', function(e) {
            e.preventDefault();

            if (crawlInProgress) {
                showToast('C\'è già un processo di crawling in corso.', 'warning');
                return;
            }

            // Raccogli i dati dal form
            const formData = new FormData(crawlForm);
            const websiteUrl = formData.get('website_url');
            const maxDepth = formData.get('max_depth');
            const maxPages = formData.get('max_pages');

            // Verifica URL
            if (!websiteUrl || (!websiteUrl.startsWith('http://') && !websiteUrl.startsWith('https://'))) {
                showToast('Inserisci un URL valido che inizi con http:// o https://', 'danger');
                return;
            }

            // Inizia il crawling
            startCrawling(websiteUrl, maxDepth, maxPages, formData);
        });
    }

    if (cancelCrawlBtn) {
        cancelCrawlBtn.addEventListener('click', function() {
            if (crawlInProgress && confirm('Sei sicuro di voler interrompere il processo di crawling?')) {
                stopCrawling(true);
            }
        });
    }

    // Gestisci i pulsanti di visualizzazione, apertura e cancellazione
    document.addEventListener('click', function(e) {
        // Visualizza contenuto URL (correzione)
        if (e.target.closest('.view-url-btn')) {
            const btn = e.target.closest('.view-url-btn');
            const urlId = btn.getAttribute('data-url-id');
            const urlTitle = btn.getAttribute('data-url-title');
            const url = btn.getAttribute('data-url');

            // Aggiorna i dati nella modal
            const modal = document.getElementById('urlContentModal');
            const contentDisplay = document.getElementById('url-content-display');
            const urlDisplay = document.getElementById('url-link');
            const openLink = document.getElementById('open-url-link');

            // Mostra informazioni iniziali
            contentDisplay.innerHTML = '<div class="spinner-border text-primary" role="status"><span class="visually-hidden">Caricamento...</span></div>';
            urlDisplay.textContent = url;
            urlDisplay.href = url;
            openLink.href = url;
            document.getElementById('urlContentModalLabel').textContent = `Contenuto: ${urlTitle}`;

            // Carica contenuto dell'URL specifico per questo progetto
            fetch('{% url "project" project.id %}', {
                method: 'POST',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams({
                    'action': 'get_url_content',
                    'url_id': urlId,
                    'csrfmiddlewaretoken': '{{ csrf_token }}'
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    contentDisplay.innerHTML = data.content.replace(/\n/g, '<br>');

                    if (data.url) {
                        urlDisplay.textContent = data.url;
                        urlDisplay.href = data.url;
                        openLink.href = data.url;
                    }

                    if (data.title) {
                        document.getElementById('urlContentModalLabel').textContent = `Contenuto: ${data.title}`;
                    }
                } else {
                    contentDisplay.innerHTML = '<div class="alert alert-danger">Errore nel caricamento del contenuto: ' + (data.error || 'errore sconosciuto') + '</div>';
                }
            })
            .catch(error => {
                console.error('Errore:', error);
                contentDisplay.innerHTML = '<div class="alert alert-danger">Errore di rete durante il caricamento del contenuto</div>';
            });
        }

        // Gestione eliminazione URL
        if (e.target.closest('.delete-url-btn')) {
            const btn = e.target.closest('.delete-url-btn');
            const urlId = btn.getAttribute('data-url-id');
            const urlTitle = btn.getAttribute('data-url-title');

            document.getElementById('delete-url-id').value = urlId;
            document.getElementById('delete-url-title').textContent = urlTitle;

            const deleteUrlModal = new bootstrap.Modal(document.getElementById('deleteUrlModal'));
            deleteUrlModal.show();
        }
    });

    // Gestione submit del form di eliminazione URL
    const deleteUrlForm = document.getElementById('delete-url-form');
    if (deleteUrlForm) {
        deleteUrlForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const urlId = document.getElementById('delete-url-id').value;

            fetch('{% url "project" project.id %}', {
                method: 'POST',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams({
                    'action': 'delete_url',
                    'url_id': urlId,
                    'csrfmiddlewaretoken': '{{ csrf_token }}'
                })
            })
            .then(response => response.json())
            .then(data => {
                const modal = bootstrap.Modal.getInstance(document.getElementById('deleteUrlModal'));
                modal.hide();

                if (data.success) {
                    const urlCard = document.querySelector(`.website-link-card[data-url-id="${urlId}"]`);
                    if (urlCard) {
                        urlCard.remove();
                        showToast('URL eliminato con successo', 'success');
                    }
                } else {
                    showToast('Errore durante l\'eliminazione: ' + (data.message || ''), 'danger');
                }
            })
            .catch(error => {
                console.error('Errore:', error);
                showToast('Errore di rete durante l\'eliminazione', 'danger');
            });
        });
    }

    function startCrawling(websiteUrl, maxDepth, maxPages, formData) {
        // Reset stato
        processedPages = 0;
        queuedPages = 1;
        failedPages = 0;
        crawledLinks = [];

        // Aggiorna UI
        crawlInProgress = true;
        startCrawlBtn.disabled = true;
        startCrawlBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Avvio...';
        crawlStatusArea.style.display = 'block';
        processedLinksContainer.innerHTML = '';
        processedPagesCount.textContent = '0';
        queuedPagesCount.textContent = '1';
        failedPagesCount.textContent = '0';
        currentUrlDisplay.textContent = websiteUrl;

        fetch('{% url "website_crawl" project.id %}', {
            method: 'POST',
            body: formData,
            headers: {
                'X-Requested-With': 'XMLHttpRequest',
                'X-CSRFToken': getCsrfToken()
            }
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                crawlJob = data.job_id;
                monitorCrawlProgress(websiteUrl);
                showToast(`Crawling avviato per ${websiteUrl}`, 'info');
            } else {
                stopCrawling();
                showToast(`Errore: ${data.message}`, 'danger');
            }
        })
        .catch(error => {
            console.error('Errore:', error);
            stopCrawling();
            showToast('Errore di rete durante l\'avvio del crawling: ' + error.message, 'danger');
        });
    }

    function getCsrfToken() {
        const name = 'csrftoken';
        const value = `; ${document.cookie}`;
        const parts = value.split(`; ${name}=`);
        if (parts.length === 2) return parts.pop().split(';').shift();
        return document.querySelector('[name=csrfmiddlewaretoken]').value;
    }

    function monitorCrawlProgress(websiteUrl) {
        if (monitorInterval) {
            clearInterval(monitorInterval);
        }

        const checkStatus = () => {
            if (!crawlInProgress) return;

            fetch(`{% url "website_crawl" project.id %}?check_status=true`, {
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                }
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    if (data.status === 'completed') {
                        finishCrawling(data.stats, websiteUrl);
                    } else if (data.status === 'failed') {
                        stopCrawling();
                        showToast(`Errore durante il crawling: ${data.error}`, 'danger');
                    } else if (data.status === 'running') {
                        if (data.stats) {
                            updateCrawlStats(data.stats);
                        }

                        if (data.visited_urls && Array.isArray(data.visited_urls)) {
                            data.visited_urls.forEach(url => {
                                if (!crawledLinks.includes(url)) {
                                    addProcessedLink(url);
                                }
                            });
                        }
                    }
                } else {
                    stopCrawling();
                    showToast('Errore nel monitoraggio del crawling', 'warning');
                }
            })
            .catch(error => {
                console.error('Errore:', error);
            });
        };

        monitorInterval = setInterval(checkStatus, 2000);
        checkStatus();
    }

    function updateCrawlStats(stats) {
        if (stats.processed_pages !== undefined) {
            processedPages = stats.processed_pages;
            processedPagesCount.textContent = processedPages;
        }

        if (stats.queued_pages !== undefined) {
            queuedPages = stats.queued_pages;
            queuedPagesCount.textContent = queuedPages;
        }

        if (stats.failed_pages !== undefined) {
            failedPages = stats.failed_pages;
            failedPagesCount.textContent = failedPages;
        }

        if (stats.current_url) {
            currentUrlDisplay.textContent = stats.current_url;
            addProcessedLink(stats.current_url);
        }
    }

    function addProcessedLink(url) {
        if (!crawledLinks.includes(url)) {
            crawledLinks.push(url);

            const linkItem = document.createElement('div');
            linkItem.className = 'processed-link-item';
            linkItem.textContent = url;

            if (processedLinksContainer.childElementCount >= 10) {
                processedLinksContainer.removeChild(processedLinksContainer.firstChild);
            }

            processedLinksContainer.appendChild(linkItem);
            processedLinksContainer.scrollTop = processedLinksContainer.scrollHeight;
        }
    }

    function stopCrawling(userRequested = false) {
        if (userRequested && crawlJob) {
            fetch(`{% url "website_crawl" project.id %}`, {
                method: 'POST',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-CSRFToken': getCsrfToken()
                },
                body: new URLSearchParams({
                    'action': 'cancel_crawl',
                    'job_id': crawlJob,
                    'csrfmiddlewaretoken': getCsrfToken()
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showToast('Processo di crawling interrotto con successo', 'success');
                } else {
                    showToast('Impossibile interrompere il processo: ' + (data.message || ''), 'warning');
                }
            })
            .catch(error => {
                console.error('Errore durante la cancellazione:', error);
                showToast('Errore di rete durante la cancellazione', 'danger');
            });
        }

        crawlInProgress = false;
        startCrawlBtn.disabled = false;
        startCrawlBtn.innerHTML = '<i class="bi bi-globe me-1"></i> Avvia Crawling';

        if (monitorInterval) {
            clearInterval(monitorInterval);
            monitorInterval = null;
        }

        const spinner = document.getElementById('crawl-spinner');
        if (spinner) {
            spinner.classList.remove('spinner-border');
            spinner.innerHTML = '<i class="bi bi-x-circle-fill text-danger"></i>';
        }

        if (crawlStatusMessage) {
            if (userRequested) {
                crawlStatusMessage.innerHTML = '<i class="bi bi-x-octagon-fill text-danger me-1"></i> Crawling interrotto dall\'utente';
            } else {
                crawlStatusMessage.innerHTML = '<i class="bi bi-check-circle-fill text-success me-1"></i> Crawling completato';
            }
        }

        crawlJob = null;
    }

    function finishCrawling(stats, websiteUrl) {
        stopCrawling();

        updateCrawlStats(stats);
        crawlStatusMessage.innerHTML = `<i class="bi bi-check-circle-fill text-success me-1"></i> Crawling completato: <strong>${stats.processed_pages}</strong> pagine elaborate, <strong>${stats.added_urls || stats.added_files || 0}</strong> contenuti aggiunti al progetto.`;

        showToast(`Crawling completato per ${websiteUrl}: ${stats.processed_pages} pagine elaborate, ${stats.added_urls || stats.added_files || 0} contenuti aggiunti`, 'success');

        setTimeout(() => {
            location.reload();
        }, 3000);
    }
}

// Funzione separata per gestire il toggle degli URL
function initUrlToggleSystem() {
    // Gestione del toggle degli URL per inclusione/esclusione nel RAG
    document.querySelectorAll('.include-url-check').forEach(checkbox => {
        checkbox.addEventListener('change', function() {
            const urlId = this.getAttribute('data-url-id');
            const isIncluded = this.checked;

            this.disabled = true;

            const label = this.nextElementSibling;
            const originalLabelText = label.textContent;
            label.innerHTML = '<i class="bi bi-hourglass-split"></i>';

            fetch('{% url "project" project.id %}', {
                method: 'POST',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'Content-Type': 'application/x-www-form-urlencoded'
                },
                body: new URLSearchParams({
                    'action': 'toggle_url_inclusion',
                    'url_id': urlId,
                    'is_included': isIncluded ? 'true' : 'false',
                    'csrfmiddlewaretoken': '{{ csrf_token }}'
                })
            })
            .then(response => {
                const contentType = response.headers.get('content-type');

                if (contentType && contentType.includes('application/json')) {
                    return response.json();
                } else {
                    return response.text().then(text => {
                        console.error('Risposta non JSON ricevuta:', text.substring(0, 200));
                        throw new Error('Il server ha restituito HTML invece di JSON');
                    });
                }
            })
            .then(data => {
                if (data.success) {
                    showToast(isIncluded ? 'URL incluso nella ricerca AI' : 'URL escluso dalla ricerca AI', 'success');

                    const urlCard = this.closest('.website-link-card');
                    if (urlCard) {
                        if (isIncluded) {
                            urlCard.classList.add('url-active');
                            urlCard.classList.remove('url-inactive');
                        } else {
                            urlCard.classList.add('url-inactive');
                            urlCard.classList.remove('url-active');
                        }
                    }
                } else {
                    this.checked = !isIncluded;
                    showToast('Errore durante l\'aggiornamento: ' + (data.message || 'errore sconosciuto'), 'danger');
                }
            })
            .catch(error => {
                console.error('Errore:', error);
                this.checked = !isIncluded;
                showToast('Errore di rete durante l\'aggiornamento: ' + error.message, 'danger');
            })
            .finally(() => {
                this.disabled = false;
                label.textContent = originalLabelText;
            });
        });
    });

    // Inizializza classi CSS per gli URL in base allo stato iniziale
    document.querySelectorAll('.include-url-check').forEach(checkbox => {
        const urlCard = checkbox.closest('.website-link-card');
        if (urlCard) {
            if (checkbox.checked) {
                urlCard.classList.add('url-active');
                urlCard.classList.remove('url-inactive');
            } else {
                urlCard.classList.add('url-inactive');
                urlCard.classList.remove('url-active');
            }
        }
    });
}

// DOMContentLoaded event listener
document.addEventListener('DOMContentLoaded', function() {
    // Inizializza il sistema di note rapide
    initQuickNoteSystem();

    // Gestione del form per la lingua del chatbot
    const languageForm = document.getElementById('chatbot-language-form');
    const saveLanguageBtn = document.getElementById('save-language-btn');
    if (languageForm) {
        languageForm.addEventListener('submit', function(e) {
            e.preventDefault();

            saveLanguageBtn.classList.add('loading');
            saveLanguageBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status"></span> Salvando...';
            saveLanguageBtn.disabled = true;

            fetch('{% url "project" project.id %}', {
                method: 'POST',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams(new FormData(languageForm))
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showToast('Lingua del chatbot aggiornata con successo!', 'success');

                    setTimeout(() => {
                        location.reload();
                    }, 1000);
                } else {
                    showToast('Errore: ' + (data.message || 'Impossibile aggiornare la lingua'), 'danger');
                }
            })
            .catch(error => {
                console.error('Errore:', error);
                showToast('Errore di rete durante l\'aggiornamento', 'danger');
            })
            .finally(() => {
                saveLanguageBtn.classList.remove('loading');
                saveLanguageBtn.innerHTML = '<i class="bi bi-check-lg me-1"></i> Salva Lingua';
                saveLanguageBtn.disabled = false;
            });
        });
    }

    // Inizializza il sistema di crawling
    initWebsiteCrawler();

    // Inizializza il sistema di toggle URL
    initUrlToggleSystem();

    // Gestione della visibilità dell'input fisso in base al tab attivo
    document.querySelectorAll('#projectTabs button').forEach(tabButton => {
        tabButton.addEventListener('shown.bs.tab', function(event) {
            const targetTab = event.target.getAttribute('data-bs-target');
            const fixedInput = document.getElementById('fixed-chat-input');
            fixedInput.style.display = targetTab === '#ask' ? 'block' : 'none';
        });
    });

    // Persistenza del tab attivo
    const triggerTabList = document.querySelectorAll('#projectTabs button');
    const activeTab = document.querySelector('#projectTabs button.active');
    if (activeTab && activeTab.getAttribute('data-bs-target') === '#ask') {
        document.getElementById('fixed-chat-input').style.display = 'block';
    }

    // Salva il tab attivo nel localStorage
    triggerTabList.forEach(tabEl => {
        tabEl.addEventListener('shown.bs.tab', function(event) {
            localStorage.setItem('activeProjectTab', event.target.getAttribute('data-bs-target'));
        });
    });

    // Modal per la visualizzazione dei documenti
    const documentModal = document.getElementById('documentModal');
    if (documentModal) {
        documentModal.addEventListener('show.bs.modal', function(event) {
            const button = event.relatedTarget;
            const fileId = button.getAttribute('data-file-id');
            const fileName = button.getAttribute('data-file-name');
            const fileSize = button.getAttribute('data-file-size');
            const filePath = button.getAttribute('data-file-path');

            document.getElementById('document-filename').textContent = fileName;
            document.getElementById('document-filesize').textContent = fileSize || '';

            const openDocumentLink = document.getElementById('open-document');
            const downloadDocumentLink = document.getElementById('download-document');

            if (openDocumentLink) openDocumentLink.href = filePath;
            if (downloadDocumentLink) downloadDocumentLink.href = filePath + '?download=1';

            const fileExtension = fileName.split('.').pop().toLowerCase();

            const iframeContainer = document.getElementById('iframe-container');
            const imageContainer = document.getElementById('image-container');
            const unsupportedContainer = document.getElementById('unsupported-file-message');
            const documentFrame = document.getElementById('document-frame');
            const imagePreview = document.getElementById('image-preview');

            iframeContainer.style.display = 'none';
            imageContainer.style.display = 'none';
            unsupportedContainer.style.display = 'none';

            if (fileExtension === 'pdf') {
                documentFrame.src = filePath;
                documentFrame.style.display = 'block';
                iframeContainer.style.display = 'block';
            }
            else if (['jpg', 'jpeg', 'png', 'gif'].includes(fileExtension)) {
                imagePreview.src = filePath;
                imageContainer.style.display = 'block';
            }
            else {
                unsupportedContainer.style.display = 'block';
            }
        });
    }

    // Modal per l'eliminazione dei file
    const deleteFileModal = document.getElementById('deleteFileModal');
    if (deleteFileModal) {
        deleteFileModal.addEventListener('show.bs.modal', function(event) {
            const button = event.relatedTarget;
            const fileId = button.getAttribute('data-file-id');
            const fileName = button.getAttribute('data-file-name');

            document.getElementById('delete-file-id').value = fileId;
            document.getElementById('delete-file-name').textContent = fileName;
        });

        // Gestione del form di eliminazione
        const deleteFileForm = document.getElementById('delete-file-form');
        if (deleteFileForm) {
            deleteFileForm.addEventListener('submit', function(e) {
                e.preventDefault();
                const fileId = document.getElementById('delete-file-id').value;

                fetch('{% url "project" project.id %}', {
                    method: 'POST',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest',
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        'action': 'delete_file',
                        'project_id': '{{ project.id }}',
                        'file_id': fileId,
                        'csrfmiddlewaretoken': '{{ csrf_token }}'
                    })
                })
                .then(response => {
                    const modal = bootstrap.Modal.getInstance(deleteFileModal);
                    modal.hide();

                    const fileCard = document.querySelector(`.document-card[data-file-id="${fileId}"]`);
                    if (fileCard) {
                        fileCard.closest('.col').remove();
                    }

                    const alertDiv = document.createElement('div');
                    alertDiv.className = 'alert alert-success alert-dismissible fade show';
                    alertDiv.innerHTML = `
                        <strong>Successo!</strong> File eliminato correttamente.
                        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                    `;
                    document.querySelector('.project-header').after(alertDiv);

                    setTimeout(() => alertDiv.remove(), 3000);

                    if (document.querySelectorAll('.document-card').length === 0) {
                        const documentsTab = document.getElementById('documents');
                        if (documentsTab) {
                            documentsTab.innerHTML = `
                                <div class="d-flex justify-content-between align-items-center mb-3">
                                    <h2 class="h5 mb-0">Documenti del progetto</h2>
                                    <button class="btn btn-sm btn-primary" data-bs-toggle="modal" data-bs-target="#uploadFilesModal">
                                        <i class="bi bi-plus-lg me-1"></i> Carica
                                    </button>
                                </div>
                                <div class="empty-state">
                                    <i class="bi bi-folder-x"></i>
                                    <h3>Nessun documento</h3>
                                    <p class="text-muted">Carica file per iniziare</p>
                                    <button class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#uploadFilesModal">
                                        <i class="bi bi-upload me-1"></i> Carica file
                                    </button>
                                </div>
                            `;
                        }
                    }
                })
                .catch(error => {
                    console.error('Errore:', error);
                    alert('Errore durante l\'eliminazione del file. Riprova più tardi.');
                });
            });
        }
    }

    // Modal per la modifica delle note
    const editNoteModal = document.getElementById('editNoteModal');
    if (editNoteModal) {
        editNoteModal.addEventListener('show.bs.modal', function(event) {
            const button = event.relatedTarget;
            const noteId = button.getAttribute('data-note-id');
            const noteContent = button.getAttribute('data-note-content');

            document.getElementById('edit-note-id').value = noteId;
            document.getElementById('edit-note-content').value = noteContent;
        });
    }

    // Funzionalità di chat con l'AI
    const sendButton = document.getElementById('send-question-btn');
    const questionInput = document.getElementById('question-input');
    const chatMessages = document.getElementById('chat-messages');

    if (sendButton && questionInput && chatMessages) {
        sendButton.addEventListener('click', sendQuestion);
        questionInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendQuestion();
            }
            if (e.key === '/' && questionInput.value === '') {
                e.preventDefault();
                showSuggestions();
            }
        });

        // Focus automatico sull'input quando la tab è attiva
        document.getElementById('ask-tab').addEventListener('shown.bs.tab', function() {
            setTimeout(() => {
                questionInput.focus();
                setTimeout(() => {
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                }, 300);
            }, 200);
        });

        // Gestione dei suggerimenti
        document.querySelectorAll('.suggestion-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                questionInput.value = this.getAttribute('data-text');
                questionInput.focus();
            });
        });

        function showSuggestions() {
            const suggestionsPopup = document.createElement('div');
            suggestionsPopup.className = 'dropdown-menu show p-2';
            suggestionsPopup.style.position = 'absolute';
            suggestionsPopup.style.bottom = '60px';
            suggestionsPopup.style.width = '100%';
            suggestionsPopup.style.maxHeight = '200px';
            suggestionsPopup.style.overflowY = 'auto';

            const suggestions = [
                { text: 'Riassumi il contenuto di tutti i documenti', icon: 'file-text' },
                { text: 'Quali sono i punti chiave del progetto?', icon: 'key' },
                { text: 'Estrai le informazioni più importanti dalle note', icon: 'journal-text' },
                { text: 'Trova eventuali contraddizioni nei documenti', icon: 'exclamation-triangle' },
                { text: 'Crea una lista di azioni da eseguire in base ai contenuti', icon: 'check2-square' },
                { text: 'Analizza i contenuti estratti dai siti web', icon: 'globe' },
                { text: 'Confronta i contenuti dei documenti con i siti web', icon: 'arrow-left-right' }
            ];

            suggestions.forEach(suggestion => {
                const item = document.createElement('button');
                item.className = 'dropdown-item d-flex align-items-center';
                item.innerHTML = `<i class="bi bi-${suggestion.icon} me-2"></i> ${suggestion.text}`;
                item.addEventListener('click', function() {
                    questionInput.value = suggestion.text;
                    suggestionsPopup.remove();
                    questionInput.focus();
                });
                suggestionsPopup.appendChild(item);
            });

            document.querySelector('.chat-input-wrapper').appendChild(suggestionsPopup);

            document.addEventListener('click', function closePopup(e) {
                if (!suggestionsPopup.contains(e.target) && e.target !== questionInput) {
                    suggestionsPopup.remove();
                    document.removeEventListener('click', closePopup);
                }
            });
        }

        function getCurrentTimeString() {
            const now = new Date();
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        function sendQuestion() {
            const question = questionInput.value.trim();
            if (!question) return;

            // Rimuovi lo stato vuoto se presente
            const emptyState = chatMessages.querySelector('.chat-empty-state');
            if (emptyState) {
                emptyState.remove();
            }

            // Aggiunge il messaggio dell'utente
            const userMsg = document.createElement('div');
            userMsg.className = 'message-container user-container';
            userMsg.innerHTML = `
                <div class="message-avatar user-avatar">
                    <i class="bi bi-person-fill"></i>
                </div>
                <div class="user-message">
                    ${question.replace(/\n/g, '<br>')}
                    <span class="message-time">${getCurrentTimeString()}</span>
                </div>
            `;
            chatMessages.appendChild(userMsg);

            scrollToBottom();

            // Reset input
            questionInput.value = '';
            questionInput.disabled = true;
            sendButton.disabled = true;
            sendButton.innerHTML = '<div class="spinner-border spinner-border-sm" role="status"></div>';

            // Aggiungi indicatore di digitazione
            const typingIndicator = document.createElement('div');
            typingIndicator.className = 'message-container';
            typingIndicator.innerHTML = `
                <div class="message-avatar ai-avatar">
                    <i class="bi bi-robot"></i>
                </div>
                <div class="typing-indicator">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            `;
            chatMessages.appendChild(typingIndicator);
            scrollToBottom();

            // Timeout per la richiesta
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 30000);

            fetch('{% url "project" project.id %}', {
                method: 'POST',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams({
                    'action': 'ask_question',
                    'project_id': '{{ project.id }}',
                    'question': question,
                    'csrfmiddlewaretoken': '{{ csrf_token }}'
                }),
                signal: controller.signal
            })
            .then(response => {
                if (!response.ok) throw new Error(`Errore HTTP! Status: ${response.status}`);
                return response.json();
            })
            .then(data => {
                // Rimuovi indicatore di digitazione
                typingIndicator.remove();

                if (data.success) {
                    // Aggiunge la risposta dell'AI
                    const aiMsg = document.createElement('div');
                    aiMsg.className = 'message-container';
                    aiMsg.innerHTML = `
                        <div class="message-avatar ai-avatar">
                            <i class="bi bi-robot"></i>
                        </div>
                        <div class="ai-message">
                            ${data.answer.replace(/\n/g, '<br>')}
                            <span class="message-time">${getCurrentTimeString()}</span>
                        </div>
                    `;
                    chatMessages.appendChild(aiMsg);

                    // Aggiorna le fonti se presenti
                    if (data.sources && data.sources.length > 0) {
                        updateSourcesTab(data.sources);

                        const sourcesNotice = document.createElement('div');
                        sourcesNotice.className = 'text-center mt-3 mb-3';
                        sourcesNotice.innerHTML = `
                            <span class="badge bg-light text-primary shadow-sm">
                                <i class="bi bi-info-circle me-1"></i>
                                ${data.sources.length} fonti disponibili nel tab "Fonti"
                            </span>
                        `;
                        chatMessages.appendChild(sourcesNotice);
                    }
                } else if (data.error === "api_auth_error") {
                    showApiAuthErrorMessage();
                } else {
                    throw new Error(data.error || 'Errore sconosciuto dal server');
                }
            })
            .catch(error => {
                typingIndicator.remove();

                if (error.message && (error.message.includes('invalid_api_key') ||
                                     error.message.includes('authentication') ||
                                     error.message.includes('api_auth_error'))) {
                    showApiAuthErrorMessage();
                } else {
                    showError(`Errore: ${error.message}`);
                }
            })
            .finally(() => {
                questionInput.disabled = false;
                sendButton.disabled = false;
                sendButton.innerHTML = '<i class="bi bi-send-fill"></i>';
                scrollToBottom();
                questionInput.focus();
                clearTimeout(timeout);
            });
        }

        function scrollToBottom() {
            setTimeout(() => {
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }, 100);
        }

        function showApiAuthErrorMessage() {
            const errorMsg = document.createElement('div');
            errorMsg.className = 'message-container';
            errorMsg.innerHTML = `
                <div class="message-avatar ai-avatar">
                    <i class="bi bi-robot"></i>
                </div>
                <div class="ai-message">
                    <div class="alert alert-danger mb-2">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        <strong>Problema con le chiavi API</strong>
                    </div>
                    <p>Non è stato possibile contattare il servizio AI a causa di un errore di autenticazione.</p>
                    <div class="alert alert-light border">
                        <h6 class="mb-2"><i class="bi bi-wrench me-1"></i> Come risolvere:</h6>
                        <ol class="mb-2">
                            <li>Vai alle <a href="{% url 'ia_engine' %}" class="fw-medium">Impostazioni del Motore IA</a></li>
                            <li>Verifica che le chiavi API siano corrette</li>
                            <li>Oppure passa alla modalità "Usa credito piattaforma"</li>
                        </ol>
                    </div>
                    <span class="message-time">${getCurrentTimeString()}</span>
                </div>
            `;
            chatMessages.appendChild(errorMsg);

            showErrorToast('Errore di autenticazione API', 'Controlla le tue chiavi API nelle impostazioni del motore IA');
        }

        function showError(message) {
            const errorMsg = document.createElement('div');
            errorMsg.className = 'message-container';
            errorMsg.innerHTML = `
                <div class="message-avatar ai-avatar">
                    <i class="bi bi-robot"></i>
                </div>
                <div class="ai-message">
                    <div class="alert alert-danger">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        ${message}
                    </div>
                    <span class="message-time">${getCurrentTimeString()}</span>
                </div>
            `;
            chatMessages.appendChild(errorMsg);
        }

        function showErrorToast(title, message) {
            const toastContainer = document.createElement('div');
            toastContainer.className = 'toast-container position-fixed top-0 end-0 p-3';
            toastContainer.style.zIndex = '1080';

            const toastEl = document.createElement('div');
            toastEl.className = 'toast show';
            toastEl.setAttribute('role', 'alert');
            toastEl.setAttribute('aria-live', 'assertive');
            toastEl.setAttribute('aria-atomic', 'true');
            toastEl.style.boxShadow = '0 0.5rem 1rem rgba(0,0,0,0.15)';
            toastEl.style.borderRadius = '0.5rem';
            toastEl.style.overflow = 'hidden';
            toastEl.style.border = 'none';

            toastEl.innerHTML = `
                <div class="toast-header bg-danger text-white">
                    <i class="bi bi-exclamation-circle me-2"></i>
                    <strong class="me-auto">${title}</strong>
                    <small>Adesso</small>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="toast" aria-label="Chiudi"></button>
                </div>
                <div class="toast-body bg-white">
                    <p class="mb-2">${message}</p>
                    <div class="mt-2 pt-2 border-top d-flex justify-content-end">
                        <a href="{% url 'ia_engine' %}" class="btn btn-sm btn-outline-primary me-2">
                            <i class="bi bi-gear me-1"></i> Vai alle impostazioni
                        </a>
                        <button type="button" class="btn btn-sm btn-secondary" data-bs-dismiss="toast">
                            Chiudi
                        </button>
                    </div>
                </div>
            `;

            toastContainer.appendChild(toastEl);
            document.body.appendChild(toastContainer);

            setTimeout(() => {
                if (document.body.contains(toastContainer)) {
                    toastContainer.remove();
                }
            }, 15000);

            toastEl.querySelector('.btn-close').addEventListener('click', () => {
                toastContainer.remove();
            });
            toastEl.querySelector('.btn-secondary').addEventListener('click', () => {
                toastContainer.remove();
            });
        }

        scrollToBottom();
    }

    // Aggiorna il tab delle fonti
    function updateSourcesTab(sources) {
        const sourcesTab = document.getElementById('sources');
        if (!sourcesTab) return;

        let sourcesHTML = `
            <h2 class="h5 mb-3">Fonti di riferimento AI</h2>
            <div class="list-group">
        `;

        sources.forEach(source => {
            sourcesHTML += `
                <div class="source-item mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-1">
                        <strong class="source-title">${source.filename || 'Documento'}</strong>
                        <small class="text-muted">${source.metadata && source.metadata.page ? 'Pag. ' + (source.metadata.page + 1) : ''}</small>
                    </div>
                    <div class="source-content small p-2 bg-light rounded">
                        ${source.content}
                    </div>
                </div>
            `;
        });

        sourcesHTML += `</div>`;
        sourcesTab.innerHTML = sourcesHTML;

        const sourcesTabButton = document.getElementById('sources-tab');
        if (sourcesTabButton) {
            if (!sourcesTabButton.querySelector('.badge')) {
                const badge = document.createElement('span');
                badge.className = 'badge bg-primary ms-1';
                badge.textContent = sources.length;
                sourcesTabButton.appendChild(badge);
            } else {
                sourcesTabButton.querySelector('.badge').textContent = sources.length;
            }
        }
    }

    // Gestione eliminazione note
    document.querySelectorAll('.delete-note-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            if (confirm('Eliminare questa nota?')) {
                const noteId = this.getAttribute('data-note-id');
                fetch('{% url "project" project.id %}', {
                    method: 'POST',
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest',
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        'action': 'delete_note',
                        'project_id': '{{ project.id }}',
                        'note_id': noteId,
                        'csrfmiddlewaretoken': '{{ csrf_token }}'
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        const noteCard = this.closest('.note-card');
                        noteCard.style.animation = 'fadeOutUp 0.3s ease forwards';
                        setTimeout(() => {
                            noteCard.remove();
                            const notesCount = document.querySelectorAll('.note-card').length;
                            const badgeElement = document.querySelector('#notes-tab .badge');
                            if (badgeElement) {
                                badgeElement.textContent = notesCount + ' note';
                            }
                            if (notesCount === 0) {
                                const notesGrid = document.querySelector('.notes-grid');
                                if (notesGrid) {
                                    notesGrid.innerHTML = `
                                        <div class="empty-notes-state text-center py-5">
                                            <i class="bi bi-journal-text fs-1 text-muted mb-3"></i>
                                            <h3>Nessuna nota ancora</h3>
                                            <p class="text-muted">Inizia aggiungendo la tua prima nota nel box sopra</p>
                                        </div>
                                    `;
                                }
                            }
                        }, 300);
                        showToast('Nota eliminata con successo', 'success');
                    } else {
                        showToast('Errore: ' + (data.error || 'Impossibile eliminare la nota'), 'danger');
                    }
                })
                .catch(error => {
                    console.error('Errore:', error);
                    showToast('Errore di rete. Riprova più tardi.', 'danger');
                });
            }
        });
    });

    // Toggle per l'inclusione delle note nella ricerca AI
    document.querySelectorAll('.include-note-check').forEach(checkbox => {
        checkbox.addEventListener('change', function() {
            const noteId = this.getAttribute('data-note-id');
            const isIncluded = this.checked;

            fetch('{% url "project" project.id %}', {
                method: 'POST',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams({
                    'action': 'toggle_note_inclusion',
                    'project_id': '{{ project.id }}',
                    'note_id': noteId,
                    'is_included': isIncluded,
                    'csrfmiddlewaretoken': '{{ csrf_token }}'
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showToast(isIncluded ? 'Nota inclusa nella ricerca AI' : 'Nota esclusa dalla ricerca AI', 'success');
                }
            })
            .catch(error => {
                console.error('Errore:', error);
                this.checked = !isIncluded;
                showToast('Errore durante l\'aggiornamento', 'danger');
            });
        });
    });

    // Gestione modifica note
    const editNoteForm = document.querySelector('#editNoteModal form');
    if (editNoteForm) {
        editNoteForm.addEventListener('submit', function(e) {
            e.preventDefault();
            const noteId = document.getElementById('edit-note-id').value;
            const content = document.getElementById('edit-note-content').value.trim();

            if (!content) return;

            fetch('{% url "project" project.id %}', {
                method: 'POST',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams({
                    'action': 'edit_note',
                    'project_id': '{{ project.id }}',
                    'note_id': noteId,
                    'content': content,
                    'csrfmiddlewaretoken': '{{ csrf_token }}'
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const modal = bootstrap.Modal.getInstance(document.getElementById('editNoteModal'));
                    modal.hide();
                    location.reload();
                } else {
                    showToast('Errore: ' + (data.error || 'Impossibile modificare la nota'), 'danger');
                }
            })
            .catch(error => {
                console.error('Errore:', error);
                showToast('Errore di rete. Riprova più tardi.', 'danger');
            });
        });
    }

    // Gestione hash URL per l'apertura automatica dei tab
    if (window.location.hash) {
        const hash = window.location.hash.substring(1);
        const tabEl = document.querySelector(`button[data-bs-target="#${hash}"]`);
        if (tabEl) {
            setTimeout(() => {
                new bootstrap.Tab(tabEl).show();
            }, 100);
        }
    }

    // Gestione toggle chatbot
    const chatbotToggle = document.getElementById('chatbot-toggle');
    if (chatbotToggle) {
        chatbotToggle.addEventListener('change', function() {
            const isEnabled = this.checked;

            this.disabled = true;

            const statusText = document.getElementById('chatbot-status-text');
            const originalText = statusText.textContent;
            statusText.innerHTML = '<span class="spinner-border spinner-border-sm" role="status"></span> Aggiornamento...';

            fetch('{% url "project" project.id %}', {
                method: 'POST',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams({
                    'action': 'toggle_chatbot',
                    'is_enabled': isEnabled,
                    'csrfmiddlewaretoken': '{{ csrf_token }}'
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    const enabledContent = document.getElementById('chatbot-enabled-content');
                    const disabledContent = document.getElementById('chatbot-disabled-content');
                    const statusBadge = document.getElementById('chatbot-status-badge');

                    if (isEnabled) {
                        enabledContent.style.display = 'block';
                        disabledContent.style.display = 'none';
                        statusText.textContent = 'Attivo';
                        statusBadge.textContent = 'ATTIVO';
                        statusBadge.classList.remove('bg-secondary');
                        statusBadge.classList.add('bg-success');
                    } else {
                        enabledContent.style.display = 'none';
                        disabledContent.style.display = 'block';
                        statusText.textContent = 'Disattivo';
                        statusBadge.textContent = 'DISATTIVO';
                        statusBadge.classList.remove('bg-success');
                        statusBadge.classList.add('bg-secondary');
                    }

                    showToast(data.message || 'Stato del chatbot aggiornato con successo', 'success');
                } else {
                    this.checked = !isEnabled;
                    statusText.textContent = originalText;
                    showToast(data.message || 'Errore nell\'aggiornamento del chatbot', 'danger');
                }
            })
            .catch(error => {
                console.error('Errore:', error);
                this.checked = !isEnabled;
                statusText.textContent = originalText;
                showToast('Errore di rete durante l\'aggiornamento: ' + error.message, 'danger');
            })
            .finally(() => {
                this.disabled = false;
            });
        });
    }

    // Gestione toggle Chatwoot
    const chatwootToggle = document.getElementById('chatwoot-toggle');
    if (chatwootToggle) {
        chatwootToggle.addEventListener('change', function() {
            const isEnabled = this.checked;

            this.disabled = true;

            const statusText = document.getElementById('chatwoot-status-text');
            const originalText = statusText.textContent;
            statusText.innerHTML = '<span class="spinner-border spinner-border-sm" role="status"></span> Aggiornamento...';

            fetch('{% url "project" project.id %}', {
                method: 'POST',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams({
                    'action': 'toggle_chatwoot',
                    'is_enabled': isEnabled,
                    'csrfmiddlewaretoken': '{{ csrf_token }}'
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    const enabledContent = document.getElementById('chatwoot-enabled-content');
                    const disabledContent = document.getElementById('chatwoot-disabled-content');

                    if (isEnabled) {
                        enabledContent.style.display = 'block';
                        disabledContent.style.display = 'none';
                        statusText.textContent = 'Attivo';
                    } else {
                        enabledContent.style.display = 'none';
                        disabledContent.style.display = 'block';
                        statusText.textContent = 'Disattivo';
                    }

                    showToast(data.message || 'Stato Chatwoot aggiornato con successo', 'success');
                } else {
                    this.checked = !isEnabled;
                    statusText.textContent = originalText;
                    showToast(data.message || 'Errore nell\'aggiornamento di Chatwoot', 'danger');
                }
            })
            .catch(error => {
                console.error('Errore:', error);
                this.checked = !isEnabled;
                statusText.textContent = originalText;
                showToast('Errore di rete durante l\'aggiornamento: ' + error.message, 'danger');
            })
            .finally(() => {
                this.disabled = false;
            });
        });
    }

    // Funzione per creare un bot Chatwoot
    function createChatwootBot() {
        const button = document.getElementById('create-chatwoot-bot-btn');
        if (!button) return;

        button.disabled = true;
        button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status"></span> Creazione in corso...';

        fetch('{% url "project" project.id %}', {
            method: 'POST',
            headers: {
                'X-Requested-With': 'XMLHttpRequest',
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: new URLSearchParams({
                'action': 'create_chatwoot_bot',
                'csrfmiddlewaretoken': '{{ csrf_token }}'
            })
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`Errore HTTP! Status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                const enabledContent = document.getElementById('chatwoot-enabled-content');

                let htmlContent = `
                    <div class="alert alert-success mb-4">
                        <i class="bi bi-check-circle me-2"></i>
                        Il chatbot Chatwoot è <strong>attivo</strong> per questo progetto con Inbox ID: ${data.inbox_id}.
                    </div>

                    <h6 class="mb-3">Istruzioni di integrazione:</h6>
                    <ol class="mb-4">
                        <li>Accedi al tuo pannello Chatwoot (chatwoot.ciunix.com)</li>
                        <li>Vai su Settings > Inboxes</li>
                        <li>Trova l'inbox "${data.inbox_name || 'RAG Bot - ' + '{{ project.name }}'}" (ID: ${data.inbox_id})</li>
                        <li>Clicca su "Widget Settings" e copia il codice di integrazione</li>
                        <li>Incolla il codice nel tuo sito web</li>
                    </ol>
                `;

                if (data.widget_code) {
                    htmlContent += `
                        <div class="card mb-4">
                            <div class="card-header d-flex justify-content-between align-items-center bg-light">
                                <h6 class="mb-0"><i class="bi bi-code-slash me-2"></i>Codice di integrazione</h6>
                                <button class="btn btn-sm btn-outline-primary" onclick="copyWidgetCode()">
                                    <i class="bi bi-clipboard me-1"></i>Copia
                                </button>
                            </div>
                            <div class="card-body">
                                <pre class="bg-light p-3 mb-0 rounded"><code id="widget-code-display">${escapeHtml(data.widget_code)}</code></pre>
                            </div>
                            <div class="card-footer bg-white">
                                <small class="text-muted">Token del sito: <span class="font-monospace">${data.website_token || ''}</span></small>
                            </div>
                        </div>
                    `;
                } else if (data.widget_error) {
                    htmlContent += `
                        <div class="alert alert-warning">
                            <i class="bi bi-exclamation-triangle me-2"></i>
                            <strong>Nota:</strong> Non è stato possibile recuperare automaticamente il codice del widget.
                            <p>Errore: ${data.widget_error}</p>
                            <p>Usa l'interfaccia di Chatwoot per ottenere il codice.</p>
                        </div>
                    `;
                } else {
                    htmlContent += `
                        <div class="alert alert-info">
                            <i class="bi bi-info-circle me-2"></i>
                            Il bot è stato creato con successo. Accedi a Chatwoot per ottenere il codice di integrazione.
                        </div>
                    `;
                }

                htmlContent += `
                    <div class="alert alert-info">
                        <i class="bi bi-info-circle me-2"></i>
                        Questo chatbot utilizzerà le informazioni RAG dal tuo progetto per rispondere alle domande degli utenti.
                    </div>

                    <div class="alert alert-warning">
                        <i class="bi bi-exclamation-triangle me-2"></i>
                        <strong>Importante:</strong> Assicurati di aver configurato il webhook Chatwoot per ricevere le notifiche dei messaggi.
                        <p class="mt-2 mb-0">URL webhook: {{ request.scheme }}://{{ request.get_host }}/chatwoot-webhook/</p>
                    </div>
                `;

                enabledContent.innerHTML = htmlContent;

                window.copyWidgetCode = function() {
                    const codeElement = document.getElementById('widget-code-display');
                    if (codeElement) {
                        const code = codeElement.textContent;
                        navigator.clipboard.writeText(code)
                            .then(() => showToast('Codice copiato negli appunti!', 'success'))
                            .catch(err => showToast('Errore nel copiare il codice', 'danger'));
                    }
                };

                showToast(data.message || 'Chatbot Chatwoot creato con successo!', 'success');
            } else {
                showToast(data.message || 'Errore nella creazione del chatbot Chatwoot', 'danger');
                button.disabled = false;
                button.innerHTML = '<i class="bi bi-plus-circle me-1"></i> Crea chatbot Chatwoot';
            }
        })
        .catch(error => {
            console.error('Errore:', error);
            showToast('Errore di rete durante la creazione del chatbot: ' + error.message, 'danger');
            button.disabled = false;
            button.innerHTML = '<i class="bi bi-plus-circle me-1"></i> Crea chatbot Chatwoot';
        });
    }

    function escapeHtml(html) {
        return html
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }

    const createBotBtn = document.getElementById('create-chatwoot-bot-btn');
    if (createBotBtn) {
        createBotBtn.addEventListener('click', createChatwootBot);
    }

    // Carica tab salvato nel localStorage
    const savedTab = localStorage.getItem('activeProjectTab');
    if (savedTab) {
        const tabEl = document.querySelector(`button[data-bs-target="${savedTab}"]`);
        if (tabEl) {
            setTimeout(() => {
                new bootstrap.Tab(tabEl).show();
            }, 100);
        }
    }

    // Gestione aggiornamento delle note che mostra i dettagli completi
    document.querySelectorAll('.note-card').forEach(card => {
        card.addEventListener('click', function(e) {
            if (e.target.closest('.note-actions') || e.target.closest('.form-check')) return;

            const contentDiv = this.querySelector('.note-content');
            if (contentDiv.classList.contains('expanded')) {
                contentDiv.classList.remove('expanded');
                contentDiv.style.maxHeight = '4.5em';
            } else {
                contentDiv.classList.add('expanded');
                contentDiv.style.maxHeight = 'none';
            }
        });
    });

    // Aggiungi CSS per l'animazione fadeOutUp
    const style = document.createElement('style');
    style.textContent = `
        @keyframes fadeOutUp {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        .note-content {
            max-height: 4.5em;
            overflow: hidden;
            transition: max-height 0.3s ease;
            cursor: pointer;
        }

        .note-content.expanded {
            max-height: none;
        }
    `;
    document.head.appendChild(style);

    // Collega il form per aggiungere manualmente un URL
    const addUrlForm = document.getElementById('addUrlModal').querySelector('form');
    if (addUrlForm) {
        addUrlForm.addEventListener('submit', function(e) {
            e.preventDefault();

            const urlInput = this.querySelector('input[name="url"]');
            const url = urlInput.value.trim();

            if (!url) {
                showToast('Inserisci un URL valido', 'warning');
                return;
            }

            const submitBtn = this.querySelector('button[type="submit"]');
            const originalBtnText = submitBtn.innerHTML;
            submitBtn.disabled = true;
            submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Aggiunta in corso...';

            fetch('{% url "project" project.id %}', {
                method: 'POST',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams({
                    'action': 'add_url',
                    'url': url,
                    'csrfmiddlewaretoken': '{{ csrf_token }}'
                })
            })
            .then(response => response.json())
            .then(data => {
                const modal = bootstrap.Modal.getInstance(document.getElementById('addUrlModal'));
                modal.hide();

                if (data.success) {
                    showToast('URL aggiunto con successo', 'success');
                    location.reload();
                } else {
                    showToast('Errore nell\'aggiunta dell\'URL: ' + (data.message || ''), 'danger');
                }
            })
            .catch(error => {
                console.error('Errore:', error);
                showToast('Errore di rete nell\'aggiunta dell\'URL', 'danger');
            })
            .finally(() => {
                submitBtn.disabled = false;
                submitBtn.innerHTML = originalBtnText;
            });
        });
    }
});

// Funzione per copiare il codice di embed
function copyEmbedCode() {
    const embedCode = document.querySelector('#chatbot pre code').textContent;
    navigator.clipboard.writeText(embedCode).then(() => {
        showToast('Codice copiato negli appunti!', 'success');
    }).catch(err => {
        showToast('Errore nel copiare il codice', 'danger');
        console.error('Errore clipboard:', err);
    });
}

// Funzione per copiare il codice widget permanente
window.copyWidgetCodePermanent = function() {
    const codeElement = document.getElementById('widget-code-permanent');
    if (codeElement) {
        const code = codeElement.textContent;
        navigator.clipboard.writeText(code)
            .then(() => showToast('Codice widget copiato negli appunti!', 'success'))
            .catch(err => showToast('Errore nel copiare il codice', 'danger'));
    }
};



 // SEZIONE PER IL CONVERSAZIONALE
</script>



<!-- Mantieni tutto il contenuto originale del file javascript.html -->
<!-- Il contenuto originale rimane identico fino a qui... -->

<script>
// ===================================================================
// CORREZIONI PER IL LOOP INFINITO DEL SISTEMA DI CRAWLING
// Aggiunto alla fine per risolvere il problema dei log infiniti
// ===================================================================

// Override delle funzioni esistenti per correggere il loop infinito
(function() {
    'use strict';

    console.log('🔧 Applicazione correzioni anti-loop per il sistema di crawling...');

    // Variabili per il controllo del loop
    let originalMonitorInterval = null;
    let statusCheckCount = 0;
    let lastStatusTimestamp = null;
    let stuckStatusDetectionCount = 0;
    const MAX_STATUS_CHECKS = 15; // Massimo 15 controlli prima di fermare
    const MAX_STUCK_DETECTIONS = 3; // Massimo 3 status identici consecutivi
    const STATUS_CHECK_DELAY = 3000; // 3 secondi invece di 1

    // Funzione per gestire il monitoraggio migliorato
    function improvedMonitorCrawlProgress(websiteUrl) {
        console.log('🔍 Avvio monitoraggio migliorato con protezione anti-loop');

        // Ferma eventuali monitoraggi precedenti
        if (originalMonitorInterval) {
            clearInterval(originalMonitorInterval);
            originalMonitorInterval = null;
        }

        // Reset contatori
        statusCheckCount = 0;
        lastStatusTimestamp = null;
        stuckStatusDetectionCount = 0;

        // Avvia nuovo monitoraggio con protezioni
        originalMonitorInterval = setInterval(() => {
            statusCheckCount++;

            // Protezione 1: Limite massimo di controlli
            if (statusCheckCount > MAX_STATUS_CHECKS) {
                console.warn(`🚫 Raggiunto limite massimo di ${MAX_STATUS_CHECKS} controlli status, ferma monitoraggio`);
                stopImprovedCrawling();
                showToast(`Monitoraggio fermato dopo ${MAX_STATUS_CHECKS} controlli per evitare loop infiniti`, 'warning');
                return;
            }

            // Protezione 2: Verifica se il crawling è ancora attivo
            if (!window.crawlInProgress) {
                console.log('🛑 Crawling non più attivo, ferma monitoraggio');
                clearInterval(originalMonitorInterval);
                originalMonitorInterval = null;
                return;
            }

            console.log(`🔍 Controllo status ${statusCheckCount}/${MAX_STATUS_CHECKS}`);
            improvedCheckStatus();

        }, STATUS_CHECK_DELAY);

        // Prima verifica immediata
        setTimeout(() => improvedCheckStatus(), 500);
    }

    // Funzione per controllo status migliorato
    function improvedCheckStatus() {
        if (!window.crawlInProgress) {
            console.log('🛑 Crawling fermato, skip controllo status');
            return;
        }

        // Verifica che project sia disponibile
        if (typeof project === 'undefined' || !project || !project.id) {
            console.error('❌ Progetto non disponibile, ferma monitoraggio');
            stopImprovedCrawling();
            return;
        }

        fetch(`/website_crawl/${project.id}/?check_status=true`, {
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            }
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            console.log(`📊 Status ricevuto (check ${statusCheckCount}):`, data.status);

            // Protezione 3: Rilevamento status bloccato
            const currentTimestamp = data.timestamp;
            if (currentTimestamp && currentTimestamp === lastStatusTimestamp) {
                stuckStatusDetectionCount++;
                console.warn(`⚠️ Status potenzialmente bloccato (${stuckStatusDetectionCount}/${MAX_STUCK_DETECTIONS})`);

                if (stuckStatusDetectionCount >= MAX_STUCK_DETECTIONS) {
                    console.error('🚫 Status bloccato rilevato, ferma crawling');
                    stopImprovedCrawling();
                    showToast('Il processo sembra bloccato. Crawling interrotto automaticamente.', 'warning');
                    return;
                }
            } else {
                stuckStatusDetectionCount = 0; // Reset se timestamp è cambiato
                lastStatusTimestamp = currentTimestamp;
            }

            // Gestisci i diversi stati
            handleImprovedStatusResponse(data);

        })
        .catch(error => {
            console.error('❌ Errore nel controllo status:', error);

            // Dopo 3 errori consecutivi, ferma il monitoraggio
            if (statusCheckCount >= 3) {
                console.error('🚫 Troppi errori consecutivi, ferma monitoraggio');
                stopImprovedCrawling();
                showToast('Errori ripetuti nel monitoraggio. Processo interrotto.', 'danger');
            }
        });
    }

    // Gestione migliorata delle risposte di status
    function handleImprovedStatusResponse(data) {
        if (!data.success) {
            console.warn('⚠️ Risposta status non valida');
            return;
        }

        switch (data.status) {
            case 'completed':
                console.log('✅ Crawling completato con successo');
                stopImprovedCrawling();

                // Aggiorna statistiche finali
                if (data.stats) {
                    updateImprovedCrawlStats(data.stats);
                }

                showToast(`Crawling completato! Processate ${data.stats?.processed_pages || 0} pagine.`, 'success');

                // Ricarica la pagina dopo un breve delay
                setTimeout(() => {
                    window.location.reload();
                }, 2000);
                break;

            case 'failed':
                console.error('❌ Crawling fallito:', data.error);
                stopImprovedCrawling();
                showToast(`Errore durante il crawling: ${data.error || 'Errore sconosciuto'}`, 'danger');
                break;

            case 'cancelled':
                console.log('🛑 Crawling cancellato dall\'utente');
                stopImprovedCrawling();
                showToast('Crawling cancellato dall\'utente', 'info');
                break;

            case 'running':
                console.log('🔄 Crawling in corso...');

                // Aggiorna statistiche solo se in corso
                if (data.stats) {
                    updateImprovedCrawlStats(data.stats);
                }

                // Aggiorna URL corrente
                if (data.url && window.currentUrlDisplay) {
                    window.currentUrlDisplay.textContent = data.url;
                }
                break;

            default:
                console.warn('⚠️ Status sconosciuto:', data.status);
                // Non interrompere per status sconosciuti, ma limita i tentativi
                break;
        }
    }

    // Funzione per fermare il crawling migliorato
    function stopImprovedCrawling() {
        console.log('🛑 Interruzione crawling migliorato');

        // Ferma il monitoraggio
        if (originalMonitorInterval) {
            clearInterval(originalMonitorInterval);
            originalMonitorInterval = null;
        }

        // Reset dello stato globale
        if (window.crawlInProgress) {
            window.crawlInProgress = false;
        }

        // Reset UI se elementi disponibili
        const startBtn = document.getElementById('start-crawl-btn');
        if (startBtn) {
            startBtn.disabled = false;
            startBtn.innerHTML = 'Avvia Crawling';
        }

        // Reset contatori
        statusCheckCount = 0;
        lastStatusTimestamp = null;
        stuckStatusDetectionCount = 0;
    }

    // Aggiornamento statistiche migliorato
    function updateImprovedCrawlStats(stats) {
        if (!stats) return;

        const processedElement = document.getElementById('processed-pages-count');
        const queuedElement = document.getElementById('queued-pages-count');
        const failedElement = document.getElementById('failed-pages-count');

        if (processedElement) processedElement.textContent = stats.processed_pages || 0;
        if (queuedElement) queuedElement.textContent = stats.queued_pages || 0;
        if (failedElement) failedElement.textContent = stats.failed_pages || 0;

        console.log(`📊 Stats aggiornate: P:${stats.processed_pages || 0}, Q:${stats.queued_pages || 0}, F:${stats.failed_pages || 0}`);
    }

    // Override della funzione originale monitorCrawlProgress se esiste
    if (typeof window.monitorCrawlProgress === 'function') {
        console.log('🔄 Override della funzione monitorCrawlProgress originale');
        window.monitorCrawlProgress = improvedMonitorCrawlProgress;
    }

    // Override della funzione originale stopCrawling se esiste
    if (typeof window.stopCrawling === 'function') {
        const originalStopCrawling = window.stopCrawling;
        window.stopCrawling = function(userCancelled = false) {
            console.log('🛑 Chiamata stopCrawling migliorata');
            stopImprovedCrawling();

            // Chiama anche la funzione originale se necessario
            if (typeof originalStopCrawling === 'function') {
                try {
                    originalStopCrawling(userCancelled);
                } catch (e) {
                    console.warn('⚠️ Errore nella chiamata alla funzione originale:', e);
                }
            }
        };
    }

    // Gestione chiusura/ricarica pagina
    window.addEventListener('beforeunload', function(e) {
        if (window.crawlInProgress) {
            stopImprovedCrawling();
        }
    });

    // Funzione di debug per verificare lo stato
    window.debugCrawlState = function() {
        console.log('🐛 Debug Crawl State:');
        console.log('- crawlInProgress:', window.crawlInProgress);
        console.log('- statusCheckCount:', statusCheckCount);
        console.log('- lastStatusTimestamp:', lastStatusTimestamp);
        console.log('- stuckStatusDetectionCount:', stuckStatusDetectionCount);
        console.log('- monitorInterval attivo:', !!originalMonitorInterval);
    };

    console.log('✅ Correzioni anti-loop applicate con successo');
    console.log('🔧 Usare window.debugCrawlState() per debug');

})();

// ===================================================================
// FINE CORREZIONI ANTI-LOOP
// ===================================================================
</script>



<script>
    // Conversational RAG JavaScript Enhancement
// Aggiunge funzionalità conversazionali al sistema RAG esistente

class ConversationalRAG {
    constructor() {
        this.currentSessionId = null;
        this.conversationMode = true; // true = conversazionale, false = tradizionale
        this.isProcessing = false;
        this.turnCounter = 0;
        this.contextMemory = [];

        this.init();
    }

    init() {
        console.log('🤖 Inizializzazione sistema RAG conversazionale');

        // Elementi DOM
        this.chatMessages = document.getElementById('chat-messages');
        this.questionInput = document.getElementById('question-input');
        this.sendButton = document.getElementById('send-question-btn');
        this.modeToggle = document.getElementById('conversation-mode-toggle');
        this.sessionInfo = document.getElementById('session-info');
        this.newSessionBtn = document.getElementById('new-session-btn');
        this.endSessionBtn = document.getElementById('end-session-btn');

        // Event listeners
        this.setupEventListeners();

        // Inizializza interfaccia
        this.updateUIForMode();
        this.addWelcomeMessage();
    }

    setupEventListeners() {
        // Invio domanda
        if (this.sendButton) {
            this.sendButton.addEventListener('click', () => this.sendQuestion());
        }

        if (this.questionInput) {
            this.questionInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    this.sendQuestion();
                }

                // Suggerimenti con '/'
                if (e.key === '/' && this.questionInput.value === '') {
                    e.preventDefault();
                    this.showSuggestions();
                }
            });
        }

        // Toggle modalità conversazionale
        if (this.modeToggle) {
            this.modeToggle.addEventListener('change', (e) => {
                this.conversationMode = e.target.checked;
                this.updateUIForMode();
                this.addSystemMessage(
                    `Modalità ${this.conversationMode ? 'conversazionale' : 'tradizionale'} attivata`
                );
            });
        }

        // Nuova sessione
        if (this.newSessionBtn) {
            this.newSessionBtn.addEventListener('click', () => this.startNewSession());
        }

        // Termina sessione
        if (this.endSessionBtn) {
            this.endSessionBtn.addEventListener('click', () => this.endCurrentSession());
        }

        // Focus automatico
        document.getElementById('ask-tab')?.addEventListener('shown.bs.tab', () => {
            setTimeout(() => {
                this.questionInput?.focus();
                this.scrollToBottom();
            }, 200);
        });
    }

    updateUIForMode() {
        const conversationalControls = document.querySelectorAll('.conversational-only');
        const traditionalControls = document.querySelectorAll('.traditional-only');

        conversationalControls.forEach(el => {
            el.style.display = this.conversationMode ? 'block' : 'none';
        });

        traditionalControls.forEach(el => {
            el.style.display = this.conversationMode ? 'none' : 'block';
        });

        // Aggiorna placeholder
        if (this.questionInput) {
            this.questionInput.placeholder = this.conversationMode
                ? "Scrivi la tua domanda... (usa '/' per suggerimenti)"
                : "Fai una domanda sui documenti...";
        }
    }

    addWelcomeMessage() {
        if (!this.chatMessages) return;

        const welcomeMsg = this.createMessageElement(
            'assistant',
            this.conversationMode
                ? "👋 Ciao! Sono il tuo assistente AI conversazionale. Posso rispondere alle tue domande mantenendo il contesto della nostra conversazione. Cosa vorresti sapere?"
                : "🤖 Assistente AI pronto. Fai una domanda sui documenti del progetto.",
            this.getCurrentTimeString(),
            { isWelcome: true }
        );

        this.chatMessages.appendChild(welcomeMsg);
        this.scrollToBottom();
    }

    async sendQuestion() {
        const question = this.questionInput.value.trim();
        if (!question || this.isProcessing) return;

        this.isProcessing = true;
        this.turnCounter++;

        // Rimuovi stato vuoto se presente
        this.removeEmptyState();

        // Aggiungi messaggio utente
        this.addUserMessage(question);

        // Reset input e disabilita controlli
        this.questionInput.value = '';
        this.questionInput.disabled = true;
        this.sendButton.disabled = true;
        this.sendButton.innerHTML = '<div class="spinner-border spinner-border-sm" role="status"></div> Elaborando...';

        // Aggiungi indicatore di digitazione
        const typingIndicator = this.addTypingIndicator();

        try {
            const response = await this.processQuestion(question);

            // Rimuovi indicatore di digitazione
            typingIndicator.remove();

            if (response.success) {
                this.handleSuccessResponse(response);
            } else {
                this.handleErrorResponse(response);
            }

        } catch (error) {
            typingIndicator.remove();
            console.error('Errore nella comunicazione:', error);
            this.addErrorMessage('Errore di comunicazione. Riprova più tardi.');
        } finally {
            this.resetInputState();
        }
    }

    async processQuestion(question) {
        const formData = new FormData();
        formData.append('action', 'ask_question');
        formData.append('question', question);
        formData.append('use_conversational', this.conversationMode.toString());

        if (this.conversationMode && this.currentSessionId) {
            formData.append('session_id', this.currentSessionId);
        }

        // Aggiungi CSRF token
        const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]');
        if (csrfToken) {
            formData.append('csrfmiddlewaretoken', csrfToken.value);
        }

        const response = await fetch(window.location.href, {
            method: 'POST',
            body: formData,
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            }
        });

        return await response.json();
    }

    handleSuccessResponse(response) {
        // Aggiorna sessione ID se in modalità conversazionale
        if (this.conversationMode && response.session_id) {
            this.currentSessionId = response.session_id;
            this.updateSessionInfo(response);
        }

        // Aggiungi risposta AI
        this.addAIMessage(
            response.answer,
            response.sources || [],
            response.processing_time || 0,
            {
                turnNumber: response.turn_number,
                contextAnalysis: response.context_analysis,
                sessionId: response.session_id
            }
        );

        // Aggiorna suggerimenti se disponibili
        if (response.suggestions) {
            this.updateSuggestions(response.suggestions);
        }

        // Salva nel context memory per riferimenti futuri
        this.contextMemory.push({
            turn: this.turnCounter,
            question: this.questionInput.dataset.lastQuestion || '',
            answer: response.answer,
            sources: response.sources || [],
            timestamp: new Date(),
            sessionId: this.currentSessionId
        });

        // Mantieni solo gli ultimi 10 turni in memoria
        if (this.contextMemory.length > 10) {
            this.contextMemory = this.contextMemory.slice(-10);
        }
    }

    handleErrorResponse(response) {
        let errorMessage = response.message || 'Si è verificato un errore';

        if (response.error === 'api_auth_error') {
            errorMessage = '🔑 Errore di autenticazione API. Verifica le chiavi API nelle impostazioni.';
        } else if (response.error === 'no_question') {
            errorMessage = '❓ Nessuna domanda fornita';
        } else if (response.error === 'conversational_error') {
            errorMessage = '💬 Errore nel sistema conversazionale. Prova a ricominciare la sessione.';
        }

        this.addErrorMessage(errorMessage);
    }

    addUserMessage(message) {
        if (!this.chatMessages) return;

        this.questionInput.dataset.lastQuestion = message; // Salva per reference

        const userMsg = this.createMessageElement('user', message, this.getCurrentTimeString());
        this.chatMessages.appendChild(userMsg);
        this.scrollToBottom();
    }

    addAIMessage(answer, sources, processingTime, metadata = {}) {
        if (!this.chatMessages) return;

        const aiMsg = this.createMessageElement('assistant', answer, this.getCurrentTimeString(), {
            sources: sources,
            processingTime: processingTime,
            metadata: metadata
        });

        this.chatMessages.appendChild(aiMsg);
        this.scrollToBottom();
    }

    addSystemMessage(message) {
        if (!this.chatMessages) return;

        const systemMsg = document.createElement('div');
        systemMsg.className = 'system-message text-center text-muted small my-2';
        systemMsg.innerHTML = `<em>${message}</em>`;

        this.chatMessages.appendChild(systemMsg);
        this.scrollToBottom();
    }

    addErrorMessage(message) {
        if (!this.chatMessages) return;

        const errorMsg = this.createMessageElement('assistant', `❌ ${message}`, this.getCurrentTimeString(), {
            isError: true
        });

        this.chatMessages.appendChild(errorMsg);
        this.scrollToBottom();
    }

    addTypingIndicator() {
        if (!this.chatMessages) return { remove: () => {} };

        const indicator = document.createElement('div');
        indicator.className = 'message-container assistant-container typing-indicator';
        indicator.innerHTML = `
            <div class="message-avatar assistant-avatar">
                <i class="bi bi-robot"></i>
            </div>
            <div class="assistant-message">
                <div class="typing-animation">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
                <div class="text-muted small">L'assistente sta scrivendo...</div>
            </div>
        `;

        this.chatMessages.appendChild(indicator);
        this.scrollToBottom();

        return indicator;
    }

    createMessageElement(role, content, timestamp, options = {}) {
        const isUser = role === 'user';
        const containerClass = isUser ? 'user-container' : 'assistant-container';
        const messageClass = isUser ? 'user-message' : 'assistant-message';
        const avatarClass = isUser ? 'user-avatar' : 'assistant-avatar';
        const avatarIcon = isUser ? 'person-fill' : 'robot';

        const messageContainer = document.createElement('div');
        messageContainer.className = `message-container ${containerClass}`;

        if (options.isError) {
            messageContainer.classList.add('error-message');
        }

        let messageHTML = `
            <div class="message-avatar ${avatarClass}">
                <i class="bi bi-${avatarIcon}"></i>
            </div>
            <div class="${messageClass}">
                ${this.formatMessageContent(content)}
                <span class="message-time">${timestamp}</span>
        `;

        // Aggiungi informazioni aggiuntive per messaggi AI
        if (!isUser && options.sources && options.sources.length > 0) {
            messageHTML += this.createSourcesHTML(options.sources);
        }

        if (!isUser && options.processingTime) {
            messageHTML += `<div class="processing-time text-muted small">⏱️ ${options.processingTime.toFixed(2)}s</div>`;
        }

        // Aggiungi badge modalità conversazionale
        if (!isUser && this.conversationMode && options.metadata) {
            const { turnNumber, contextAnalysis, sessionId } = options.metadata;
            messageHTML += `
                <div class="conversation-metadata small text-muted mt-2">
                    <span class="badge bg-secondary me-1">Turno ${turnNumber || '?'}</span>
                    ${sessionId ? `<span class="badge bg-info me-1">Sessione ${sessionId.substring(0, 8)}</span>` : ''}
                    ${contextAnalysis?.needs_context ? '<span class="badge bg-warning">Contesto utilizzato</span>' : ''}
                </div>
            `;
        }

        messageHTML += '</div>';
        messageContainer.innerHTML = messageHTML;

        return messageContainer;
    }

    createSourcesHTML(sources) {
        if (!sources || sources.length === 0) return '';

        let sourcesHTML = '<div class="sources-container mt-2"><h6 class="sources-title">📚 Fonti utilizzate:</h6>';

        sources.forEach((source, index) => {
            const sourceIcon = this.getSourceIcon(source.type);
            const fileName = source.filename || source.name || 'Fonte sconosciuta';

            sourcesHTML += `
                <div class="source-item">
                    <strong>${sourceIcon} ${fileName}</strong>
                    ${source.content ? `<div class="source-content">${source.content.substring(0, 200)}${source.content.length > 200 ? '...' : ''}</div>` : ''}
                    ${source.url ? `<div class="source-url"><a href="${source.url}" target="_blank">🔗 Apri link</a></div>` : ''}
                </div>
            `;
        });

        sourcesHTML += '</div>';
        return sourcesHTML;
    }

    getSourceIcon(type) {
        const icons = {
            'pdf': '📄',
            'txt': '📝',
            'docx': '📋',
            'note': '📓',
            'url': '🌐',
            'file': '📁'
        };
        return icons[type] || '📄';
    }

    formatMessageContent(content) {
        // Converte newlines in <br> e applica altre formattazioni
        return content
            .replace(/\n/g, '<br>')
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.*?)\*/g, '<em>$1</em>');
    }

    showSuggestions() {
        const suggestionsPopup = document.createElement('div');
        suggestionsPopup.className = 'dropdown-menu show p-2 suggestions-popup';
        suggestionsPopup.style.position = 'absolute';
        suggestionsPopup.style.bottom = '60px';
        suggestionsPopup.style.width = '100%';
        suggestionsPopup.style.maxHeight = '300px';
        suggestionsPopup.style.overflowY = 'auto';
        suggestionsPopup.style.zIndex = '1000';

        // Suggerimenti contestuali se in modalità conversazionale
        let suggestions;
        if (this.conversationMode && this.currentSessionId) {
            suggestions = this.getContextualSuggestions();
        } else {
            suggestions = this.getDefaultSuggestions();
        }

        suggestions.forEach(suggestion => {
            const item = document.createElement('button');
            item.className = 'dropdown-item d-flex align-items-center suggestion-item';
            item.innerHTML = `<i class="bi bi-${suggestion.icon} me-2"></i> ${suggestion.text}`;
            item.addEventListener('click', () => {
                this.questionInput.value = suggestion.text;
                suggestionsPopup.remove();
                this.questionInput.focus();
            });
            suggestionsPopup.appendChild(item);
        });

        // Aggiungi header
        const header = document.createElement('div');
        header.className = 'dropdown-header';
        header.textContent = this.conversationMode ? 'Suggerimenti Contestuali' : 'Suggerimenti Generali';
        suggestionsPopup.insertBefore(header, suggestionsPopup.firstChild);

        this.questionInput.parentElement.appendChild(suggestionsPopup);

        // Chiudi al click esterno
        const closePopup = (e) => {
            if (!suggestionsPopup.contains(e.target) && e.target !== this.questionInput) {
                suggestionsPopup.remove();
                document.removeEventListener('click', closePopup);
            }
        };
        document.addEventListener('click', closePopup);
    }

    getContextualSuggestions() {
        const contextualSuggestions = [
            { text: 'Puoi darmi più dettagli su questo?', icon: 'zoom-in' },
            { text: 'Come si collega questo al resto?', icon: 'diagram-3' },
            { text: 'Ci sono esempi pratici?', icon: 'lightbulb' },
            { text: 'Qual è il prossimo passo?', icon: 'arrow-right-circle' },
            { text: 'Puoi approfondire questo punto?', icon: 'search' },
            { text: 'Come posso applicare queste informazioni?', icon: 'gear' }
        ];

        return contextualSuggestions.concat(this.getDefaultSuggestions().slice(0, 3));
    }

    getDefaultSuggestions() {
        return [
            { text: 'Riassumi il contenuto di tutti i documenti', icon: 'file-text' },
            { text: 'Quali sono i punti chiave del progetto?', icon: 'key' },
            { text: 'Estrai le informazioni più importanti dalle note', icon: 'journal-text' },
            { text: 'Trova eventuali contraddizioni nei documenti', icon: 'exclamation-triangle' },
            { text: 'Crea una lista di azioni da eseguire', icon: 'check2-square' },
            { text: 'Analizza i contenuti estratti dai siti web', icon: 'globe' },
            { text: 'Confronta i contenuti dei documenti', icon: 'arrow-left-right' }
        ];
    }

    updateSuggestions(suggestions) {
        const suggestionsContainer = document.getElementById('suggestions-container');
        if (!suggestionsContainer) return;

        suggestionsContainer.innerHTML = '';

        suggestions.forEach(suggestion => {
            const btn = document.createElement('button');
            btn.className = 'btn btn-outline-secondary btn-sm me-2 mb-2 suggestion-btn';
            btn.textContent = suggestion;
            btn.addEventListener('click', () => {
                this.questionInput.value = suggestion;
                this.questionInput.focus();
            });
            suggestionsContainer.appendChild(btn);
        });
    }

    startNewSession() {
        if (this.isProcessing) return;

        // Conferma se c'è una sessione attiva
        if (this.currentSessionId && this.turnCounter > 0) {
            if (!confirm('Vuoi davvero iniziare una nuova conversazione? La conversazione attuale verrà terminata.')) {
                return;
            }
        }

        // Reset stato
        this.currentSessionId = null;
        this.turnCounter = 0;
        this.contextMemory = [];

        // Pulisci chat
        if (this.chatMessages) {
            this.chatMessages.innerHTML = '';
        }

        // Aggiungi messaggio di benvenuto
        this.addWelcomeMessage();
        this.addSystemMessage('🆕 Nuova conversazione iniziata');

        // Reset UI
        this.updateSessionInfo(null);

        console.log('🆕 Nuova sessione conversazionale iniziata');
    }

    async endCurrentSession() {
        if (!this.currentSessionId || this.isProcessing) return;

        if (!confirm('Vuoi terminare la conversazione corrente?')) return;

        try {
            const formData = new FormData();
            formData.append('action', 'end_conversation_session');
            formData.append('session_id', this.currentSessionId);

            const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]');
            if (csrfToken) {
                formData.append('csrfmiddlewaretoken', csrfToken.value);
            }

            const response = await fetch(window.location.href, {
                method: 'POST',
                body: formData,
                headers: { 'X-Requested-With': 'XMLHttpRequest' }
            });

            const result = await response.json();

            if (result.success) {
                this.addSystemMessage('🔚 Conversazione terminata');
                this.currentSessionId = null;
                this.updateSessionInfo(null);
            } else {
                this.addErrorMessage('Errore nella terminazione della sessione');
            }

        } catch (error) {
            console.error('Errore nella terminazione:', error);
            this.addErrorMessage('Errore di comunicazione durante la terminazione');
        }
    }

    updateSessionInfo(responseData) {
        if (!this.sessionInfo) return;

        if (this.currentSessionId && responseData) {
            this.sessionInfo.innerHTML = `
                <div class="session-status active">
                    <div class="session-id">
                        <strong>Sessione:</strong> ${this.currentSessionId.substring(0, 8)}...
                    </div>
                    <div class="turn-counter">
                        <strong>Turno:</strong> ${responseData.turn_number || this.turnCounter}
                    </div>
                    ${responseData.context_analysis?.context_score ?
                        `<div class="context-score">
                            <strong>Contesto:</strong> ${(responseData.context_analysis.context_score * 100).toFixed(0)}%
                        </div>` : ''
                    }
                </div>
            `;
        } else {
            this.sessionInfo.innerHTML = '<div class="session-status inactive">Nessuna sessione attiva</div>';
        }
    }

    removeEmptyState() {
        const emptyState = this.chatMessages?.querySelector('.chat-empty-state');
        if (emptyState) {
            emptyState.remove();
        }
    }

    resetInputState() {
        this.isProcessing = false;
        this.questionInput.disabled = false;
        this.sendButton.disabled = false;
        this.sendButton.innerHTML = '<i class="bi bi-send"></i>';
        this.questionInput.focus();
    }

    scrollToBottom() {
        if (this.chatMessages) {
            setTimeout(() => {
                this.chatMessages.scrollTop = this.chatMessages.scrollHeight;
            }, 100);
        }
    }

    getCurrentTimeString() {
        const now = new Date();
        return now.toLocaleTimeString('it-IT', {
            hour: '2-digit',
            minute: '2-digit'
        });
    }
}

// Inizializza il sistema quando il DOM è pronto
document.addEventListener('DOMContentLoaded', function() {
    // Verifica se siamo nella pagina giusta
    if (document.getElementById('chat-messages')) {
        window.conversationalRAG = new ConversationalRAG();
        console.log('✅ Sistema RAG conversazionale inizializzato');
    }
});

// CSS aggiuntivo da inserire (può essere in un file separato)
const conversationalCSS = `
<style>
.conversational-only {
    display: none;
}

.conversation-metadata .badge {
    font-size: 0.7em;
}

.typing-indicator {
    opacity: 0.7;
}

.typing-animation {
    display: flex;
    align-items: center;
    gap: 4px;
    margin-bottom: 5px;
}

.typing-animation span {
    height: 8px;
    width: 8px;
    background-color: #007bff;
    border-radius: 50%;
    animation: typing 1.4s infinite ease-in-out;
}

.typing-animation span:nth-child(1) { animation-delay: -0.32s; }
.typing-animation span:nth-child(2) { animation-delay: -0.16s; }

@keyframes typing {
    0%, 80%, 100% { transform: scale(0); opacity: 0.5; }
    40% { transform: scale(1); opacity: 1; }
}

.error-message .assistant-message {
    background-color: #f8d7da;
    border-color: #f5c6cb;
    color: #721c24;
}

.system-message {
    padding: 8px 16px;
    margin: 8px 0;
    background-color: #f8f9fa;
    border-radius: 16px;
    border: 1px solid #e9ecef;
}

.session-status.active {
    color: #28a745;
    font-size: 0.85em;
}

.session-status.inactive {
    color: #6c757d;
    font-size: 0.85em;
}

.suggestions-popup {
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.suggestion-item:hover {
    background-color: #f8f9fa;
}

.sources-container {
    background-color: #f8f9fa;
    border-radius: 8px;
    padding: 12px;
    margin-top: 8px;
}

.sources-title {
    color: #495057;
    font-size: 0.9em;
    margin-bottom: 8px;
}

.source-item {
    margin-bottom: 8px;
    padding-bottom: 8px;
    border-bottom: 1px solid #e9ecef;
}

.source-item:last-child {
    border-bottom: none;
    margin-bottom: 0;
}

.source-content {
    font-size: 0.85em;
    color: #6c757d;
    margin-top: 4px;
}

.source-url a {
    font-size: 0.8em;
    text-decoration: none;
}

.processing-time {
    margin-top: 4px;
    font-style: italic;
}
</style>
`;

// Inietta CSS se non già presente
if (!document.getElementById('conversational-css')) {
    const styleElement = document.createElement('div');
    styleElement.id = 'conversational-css';
    styleElement.innerHTML = conversationalCSS;
    document.head.appendChild(styleElement);
}
</script>